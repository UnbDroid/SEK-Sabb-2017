#define L_MOTOR OUT_A
#define R_MOTOR OUT_C
#define MOTORS  OUT_AC
#define GATE 	OUT_B

#define POT -50

#define OFFSET_SAMPLES 3000

#define L_COLOR IN_1
#define R_COLOR IN_4
#define GYRO    IN_3

#define BLACK 	 3
#define WHITE 	 4
#define RED   	 0
#define BLUE  	 1
#define GREEN 	 2
#define OUT		 5

#define DIREITA  0
#define FRENTE 	 1
#define ESQUERDA 2

#define DIAMETER 8.3 //Aproximado
#define RAIO_RODA 4

byte color_r, color_l, nova_r, nova_l;

/* Calculo do offset da leitura do giroscopio */
float GetGyroOffset(){
    float gyro_sum = 0;
	
    for(int i = 0; i < OFFSET_SAMPLES; i++)
        gyro_sum += SensorHTGyro(GYRO, 0);
    
    /* Aproxima para o inteiro mais próximo */
    return (gyro_sum/OFFSET_SAMPLES);
}

char dir[3][3] = {{-1, -1, -1}, {-1, -1, -1}, {-1, -1, -1}};
byte last_color = BLACK, last_dir = 0, abdul=0;

float offset_LM, offset_RM, offset_G;

void SetOffsets(void){ // So seta os offsets :)  
    offset_LM = abs(MotorRotationCount(L_MOTOR));
    offset_RM = abs(MotorRotationCount(R_MOTOR));
    offset_G = abs(MotorRotationCount(GATE));

}

float CalculaAngulo(float distancia){ // Calcula o angulo em graus que o motor deve girar para que seja percorrida a distancia 
									  //passada como argumento

    float angulo_motor;
    angulo_motor = (distancia*360)/(2*PI*RAIO_RODA);
    return abs(angulo_motor);

}

void AndaReto(float distancia){ // Anda pra frente ou pra tras ate atingir a distancia passada como argumento

    float angulo_limite = abs(CalculaAngulo(distancia));

    SetOffsets();
    if(distancia > 0){
        OnFwdReg(MOTORS, POT, OUT_REGMODE_SYNC);
    	while(abs(abs(MotorRotationCount(R_MOTOR)) - offset_RM) < angulo_limite && abs(abs(MotorRotationCount(L_MOTOR)) - offset_LM) < angulo_limite);
    }else{
        OnRevReg(MOTORS, POT, OUT_REGMODE_SYNC);
        while(abs(abs(MotorRotationCount(R_MOTOR)) - offset_RM) < angulo_limite && abs(abs(MotorRotationCount(L_MOTOR)) - offset_LM) < angulo_limite);
    }
    Off(MOTORS);
}

sub TurnGyroDireita(float degrees){ // Faz apenas a roda direita rodar, para frente ou para tras ate que o robo gire a angulacao desejada
    float angle = 0, gyro = 0;
    unsigned long time, prev_time;
    Off(MOTORS);
    float offset = GetGyroOffset();
    time = CurrentTick();
    if(degrees < 0){ // Sentido anti-horario
        OnFwd(R_MOTOR, -75);
        while(angle > degrees){
            prev_time = time;
            time = CurrentTick();
            gyro = SensorHTGyro(GYRO, offset);
            angle += gyro * (time - prev_time)/1000.0;
        }
    } else { // Sentido horario
        OnRev(R_MOTOR, -75);
        while(angle < degrees){ 
            prev_time = time;
            time = CurrentTick();
            gyro = SensorHTGyro(GYRO, offset);
            angle += gyro * (time - prev_time)/1000.0;
        }       
    }
    Off(MOTORS);

}

sub TurnGyroEsquerda(float degrees){ // Faz apenas a roda esquerda rodar, para frente ou para tras ate que o robo gire a angulacao desejada
    float angle = 0, gyro = 0;
    unsigned long time, prev_time;

    Off(MOTORS);
    float offset = GetGyroOffset();
    time = CurrentTick()
    if(degrees < 0){ // Sentido anti-horario
        OnRev(L_MOTOR, POT-25);
        while(angle > degrees){
            prev_time = time;
            time = CurrentTick();
            gyro = SensorHTGyro(GYRO, offset);
            angle += gyro * (time - prev_time)/1000.0;
        }
    } else { // Sentido horario
        OnFwd(L_MOTOR, POT-25);
        while(angle < degrees){
            prev_time = time;
            time = CurrentTick();
            gyro = SensorHTGyro(GYRO, offset);
            angle += gyro * (time - prev_time)/1000.0;
        }
    }
    Off(MOTORS);

}

/* Função que tabela a saída dos sensores de luz para as cores lidas*/
sub detect_colors(){
	byte num_r, red_r, green_r, blue_r, white_r, num_l, red_l, green_l, blue_l, white_l;

    ReadSensorHTColor2Active(R_COLOR, num_r, red_r, green_r, blue_r, white_r);
	ReadSensorHTColor2Active(L_COLOR, num_l, red_l, green_l, blue_l, white_l);	
	
	/*Achei melhor if em vez de switch pois os valores lidos dependem da calibração*/
	if(num_r == 4)
		color_r = GREEN;
	else if(num_r == 14)
		if(white_r > 217) // Parametros experimentais, confia rsrs
			color_r = WHITE;
		else
			color_r = OUT;	
	else if(num_r == 3 || num_r == 2)
		color_r = BLUE;
	else if(num_r == 8)
		color_r = RED;
	else
		color_r = BLACK;
			
		
	if(num_l == 4)
		color_l = GREEN;
	else if(num_l == 14)
		if(white_l > 217) // Parametros experimentais, confia rsrs
			color_l = WHITE;
		else
			color_l = OUT;	
	else if(num_l == 3 || num_l == 2)
		color_l = BLUE;
	else if(num_l == 8)
		color_l = RED;	
	else
		color_l = BLACK;					
}

/*Escolhe para onde virar*/
sub choose_path(){
	//A condição de entrada nessa parte será alterada de acordo com a calibração dos sensores
	//Adota-se que num_r retorna o valor da cor de acordo com os 'defines' utilizados, se não, utilizar outra variável
	//e mapear a essa varíavel com num_r
	if(nova_r == nova_l && nova_r == BLACK){
		ClearLine(LCD_LINE1);
        TextOut(0, LCD_LINE1, "Naoerapraentraraqui!!!");
		// O preto 'nunca' vai ser a primeira cor a ser lida
		// nunca = Desde que o robô não ultrapasse uma cor sem ler absolutamente nada
		if(last_color>=0 && last_color <=2)
			dir[last_color][last_dir] = 0;
		//TurnGyro(180);
		last_color = BLACK;
	}
	else if(nova_r == nova_l && nova_r<3 && nova_r >= 0){
		
		if(last_color != BLACK){
			//Já conectou uma cor com uma direção, logo, nega as outras possibilidades que envolvem essa cor/direção
			dir[last_color][last_dir] = 1;
			dir[last_color][(last_dir+1)%3] = 0;
			dir[last_color][(last_dir+2)%3] = 0;
			dir[(last_color+1)%3][last_dir] = 0;
			dir[(last_color+2)%3][last_dir] = 0;
		};
		
		//Verifica qual o próximo caminho livre para seguir, -1 para teste e 1 para certeza
		byte i;
		for(i=0;i<3;i++){
			if(dir[nova_r][i] != 0){
				if(i == DIREITA){
					//Só é possível pegar a direita chegando do caminho certo, seguindo a lógica do código, logo
					//tudo o que é necessário é virar 90 graus para a direita.
					
					TurnGyroDireita(15);
					TurnGyroEsquerda(15);
					TurnGyroDireita(15);
					TurnGyroEsquerda(13);
					
					ClearLine(LCD_LINE1);
        			TextOut(0, LCD_LINE1, "Virou pra direita");
        	
					Wait(800);
					last_dir = DIREITA;
					break;
				}
				else if(i == FRENTE){
					// Se a próxima possibilidade for ir em frente, é só virar 90 graus se chegou do preto ou não fazer nada	
					// A direção para frente nunca será a primeira a ser testada, logo, pode-se assumir o que está em cima
					// Salvo na utilização de arquivos
					if(last_color == BLACK){
						// Descomentar quando for utilizar as funções novas TurnGyro(90);
						AndaReto(30);
					};
					last_dir = FRENTE;
					break;			
				}
				else {
					// Quado o código cai nessa condição, as duas outras direções para essa cor já foram discartadas,
					// se ele não veio do preto, a única direção que resta é a esquerda, se veio e a última a tentar foi frente
					// segue o baile.
					if(last_color != BLACK){
						
						TurnGyroEsquerda(-15);
						TurnGyroDireita(-15);
						TurnGyroEsquerda(-15);
						TurnGyroDireita(-13);
						
					}
					else {
						if(last_dir == FRENTE){
							AndaReto(30);
							//TurnGyro(90);
						};
					};
					last_dir = ESQUERDA;
					break;
				};
			};
		};
		ClearLine(LCD_LINE1);
        TextOut(0, LCD_LINE1, "Saiu do for");
        	
		last_color = nova_r;
		OnFwdReg(MOTORS, POT, OUT_REGMODE_SYNC);
	};
}

task main(){
	/*Set básico dos sensores*/
    SetSensorHTGyro(GYRO);
    SetSensorLowspeed(L_COLOR);
    SetSensorLowspeed(R_COLOR);
    SetHTColor2Mode(L_COLOR, HT_CMD_COLOR2_ACTIVE);
    SetHTColor2Mode(R_COLOR, HT_CMD_COLOR2_ACTIVE);
	
	
	OnFwdReg(MOTORS, POT, OUT_REGMODE_SYNC);
	while(true){
		detect_colors();
		//walk_straight(0, color_r, color_l);
        if(color_r == OUT && color_l == WHITE){
			Off(MOTORS);
			AndaReto(-4);
			TurnGyroEsquerda(-5);
			OnFwdReg(MOTORS, POT, OUT_REGMODE_SYNC);
        };
        if(color_r == WHITE && color_l == OUT){
        	Off(MOTORS);
			AndaReto(-4);
			TurnGyroDireita(5);
			OnFwdReg(MOTORS, POT, OUT_REGMODE_SYNC);        	
        };
        if(color_r != WHITE || color_l != WHITE){
        	Off(MOTORS);
        	
         	ClearLine(LCD_LINE2);
        	TextOut(0, LCD_LINE2, "LendoR: ");
        	ClearLine(LCD_LINE3);
        	NumOut(50, LCD_LINE3, color_r);
        	ClearLine(LCD_LINE4);
        	TextOut(0, LCD_LINE4, "LendoL: ");
        	ClearLine(LCD_LINE5);
        	NumOut(50, LCD_LINE5, color_l);
        	
        	//Wait(500);
        	
        	nova_r = color_r;
        	nova_l = color_l;
		    OnFwdReg(MOTORS, POT, OUT_REGMODE_SYNC);
			while(nova_r == color_r || nova_l == color_l){
				detect_colors();
				ClearLine(LCD_LINE2);
        		TextOut(0, LCD_LINE2, "LendoR: ");
        		ClearLine(LCD_LINE3);
        		NumOut(50, LCD_LINE3, color_r);
        		ClearLine(LCD_LINE4);
        		TextOut(0, LCD_LINE4, "LendoL: ");
        		ClearLine(LCD_LINE5);
        		NumOut(50, LCD_LINE5, color_l);
			}
			Off(MOTORS);
			Wait(400);
			AndaReto(2);
			Off(MOTORS);

			ClearLine(LCD_LINE1);
			TextOut(0, LCD_LINE1, "Parou de ler a nova");			
			Wait(800);
			
        	choose_path();
        };
	};
}
