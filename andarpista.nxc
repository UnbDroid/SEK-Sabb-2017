#define L_MOTOR OUT_A
#define R_MOTOR OUT_C
#define MOTORS OUT_AC
#define GATE OUT_B

#define POT 60

#define L_COLOR IN_1
#define R_COLOR IN_4
#define GYRO IN_3

#define RED 0
#define GREEN 1
#define BLUE 2
#define BLACK -1
#define DIREITA 0
#define FRENTE 1
#define ESQUERDA 2

char dir[][] = {{-1, -1, -1}, {-1, -1, -1}, {-1, -1, -1}}, last_color=4;
byte red_r, green_r, blue_r, white_r, num_r, red_l, green_l, blue_l, white_l, num_l, last_dir;

void choose_path(){
	//A condição de entrada nessa parte será alterada de acordo com a calibração dos sensores
	//Adota-se que num_r retorna o valor da cor de acordo com os 'defines' utilizados, se não, utilizar outra variável
	//e mapear a essa varíavel com num_r
	if(color_r == color_l && color_r == BLACK){
		dir[last_color][last_dir] = 0;
		TurnGyro(180);
		last_color = BLACK;	
	}
	else{
		
		if(last_color != BLACK){
			//Já conectou uma cor com uma direção, logo, nega as outras possibilidades que envolvem essa cor/direção
			dir[last_color][last_dir] = 1;
			dir[last_color][(last_dir+1)%3] = 0;
			dir[last_color][(last_dir+2)%3] = 0;
			dir[(last_color+1)%3][last_dir] = 0;
			dir[(last_color+2)%3][last_dir] = 0;
		};
		
		last_color = color_r;
		
		//Verifica qual o próximo caminho livre para seguir, -1 para teste e 1 para certeza
		for(byte i=0;i<3;i++){
			if(dir[num_r][i] != 0){
				switch(i){
					//Só é possível pegar a direita chegando do caminho certo, seguindo a lógica do código, logo
					//tudo o que é necessário é virar 90 graus para a direita.
					case DIREITA:
						TurnGyro(90);
						last_dir = DIREITA;	
						break;
					//Se a próxima possibilidade for ir em frente, é só virar 90 graus se chegou do preto ou não fazer nada	
					case FRENTE:
						if(last_color == BLACK)
							TurnGyro(90);
						last_dir = FRENTE;
						break;	
					//Pode-se decidir pelo caminho da esquerda chegando de três maneiras diferentes, do caminho certo, do preto
					//da direita ou do preto quando vai em frente	
					case ESQUERDA:
						if(dir[num_r][i] == 1)
							TurnGyro(-90);
						else {
							if(last_color == BLACK)
								if(last_dir == FRENTE)
									TurnGyro(90);
						}		
						last_dir = ESQUERDA;		
						break;	
				};
			};
		};
	};
}

task main(){
    SetSensorHTGyro(GYRO);
    SetSensorLowspeed(L_COLOR);
    SetSensorLowspeed(R_COLOR);
    SetHTColor2Mode(L_COLOR, HT_CMD_COLOR2_ACTIVE);
    SetHTColor2Mode(R_COLOR, HT_CMD_COLOR2_ACTIVE);
    //SetSensorUltrasonic(R_ULTRAS);
    //SetSensorUltrasonic(L_ULTRAS);

    while(true){
        OnFwdReg(MOTORS, POT, OUT_REGMODE_SYNC);

        ReadSensorHTColor2Active(R_COLOR, num_r, red_r, green_r, blue_r, white_r);
		ReadSensorHTColor2Active(L_COLOR, num_l, red_l, green_l, blue_l, white_l);

		if(num_r != WHITE && num_l != WHITE)
			choose_path();
	
        if(SensorUS(R_ULTRAS) <= 25){
            Wait(900);
            Off(MOTORS);
            PickUpPeople();
        };
	};        
}
